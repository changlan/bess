# Copyright (c) 2018, Chang Lan
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
#
# * Neither the names of the copyright holders nor the names of their
# contributors may be used to endorse or promote products derived from this
# software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import time
import pprint
from random import randint

import scapy.all as scapy

pkt = scapy.Ether()/scapy.IP()/scapy.TCP()

Source() -> rewrite::Rewrite(templates=[bytes(pkt)]) -> \
  RandomUpdate(fields=[{'offset': 26, 'size': 4, 'min': 0x00000001, 'max': 0xffffffff},
                       {'offset': 30, 'size': 4, 'min': 0x00000001, 'max': 0xffffffff},
                       {'offset': 34, 'size': 2, 'min': 0x0001, 'max': 0xffff},
                       {'offset': 36, 'size': 2, 'min': 0x0001, 'max': 0xffff}]) -> \
  acl::DPDKACL(rules=[{
    'src_ip': '0.0.0.0/0',
    'dst_ip': '0.0.0.0/0',
    'drop': False
  }]) -> Sink()

def random_prefix():
    return '.'.join([str(randint(1, 255)) for _ in range(4)]) + '/32'

def run_testcase(rule_num):
    acl.clear()

    for _ in range(rule_num // 1000):
      rules = [{
        'ipproto': 0x06,
        'src_ip': random_prefix(),
        'dst_ip': random_prefix(),
        'src_port': randint(1, 65535),
        'dst_port': randint(1, 65535),
        'drop': False
      } for i in range(1000)]
      acl.add(rules=rules)

    rules = [{
      'ipproto': 0x06,
      'src_ip': random_prefix(),
      'dst_ip': random_prefix(),
      'src_port': randint(1, 65535),
      'dst_port': randint(1, 65535),
      'drop': False
    } for i in range(rule_num % 1000)]

    rules.append({
      'src_ip': '0.0.0.0/0',
      'dst_ip': '0.0.0.0/0',
      'drop': False
    })

    acl.add(rules=rules)

    bess.resume_all()

    old_stats = bess.get_module_info(acl.name).ogates
    time.sleep(5)
    new_stats = bess.get_module_info(acl.name).ogates

    pps = (new_stats[0].pkts - old_stats[0].pkts) / \
        (new_stats[0].timestamp - old_stats[0].timestamp)

    print('Total: %8.3fMpps ' % (pps / 1000000.0))

    bess.pause_all()

testcases = [
    1,
    10,
    100,
    1000,
    10000,
    100000,
    1000000,
]

for rule_num in testcases:
    print('Rule num %d:\t\t' % rule_num, end=' ')
    run_testcase(rule_num)
